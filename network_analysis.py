#!/usr/bin/env python3
"""Network analysis for Telegram Snowball Sampling data.

This script performs network analysis on the edge list data generated by the
Telegram Snowball Sampling Tool. It uses NetworkX to calculate various metrics
and generates summary statistics about the network.
"""

import os
import csv
import networkx as nx
import matplotlib.pyplot as plt
import pandas as pd
import argparse
import logging
from config import Config
from typing import Any

# Set up logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)


def load_edge_list(edge_list_path: str) -> nx.DiGraph:
    """Load the edge list from a CSV file into a NetworkX graph.

    Args:
        edge_list_path (str): Path to the edge list CSV file.

    Returns:
        nx.DiGraph: A directed graph representing the network.
    """
    logger.info("Loading edge list from %s", edge_list_path)

    # Create a directed graph
    G = nx.DiGraph()

    try:
        # Read the edge list CSV file
        with open(edge_list_path, 'r', encoding='utf-8', newline='') as file:
            reader = csv.DictReader(file)

            # Check if the file has the expected columns
            expected_columns = ['From_Channel_ID', 'From_Channel_Name', 'From_Channel_Username',
                                'To_Channel_ID', 'To_Channel_Name', 'To_Channel_Username',
                                'ConnectionType', 'Weight']

            if not all(col in reader.fieldnames for col in expected_columns):
                logger.warning("Edge list file is missing expected columns")

            # Add nodes and edges to the graph
            for row in reader:
                # Add source node if it doesn't exist
                if row['From_Channel_ID'] not in G:
                    G.add_node(row['From_Channel_ID'],
                               name=row['From_Channel_Name'],
                               username=row['From_Channel_Username'])

                # Add target node if it doesn't exist
                if row['To_Channel_ID'] not in G:
                    G.add_node(row['To_Channel_ID'],
                               name=row['To_Channel_Name'],
                               username=row['To_Channel_Username'])

                # Add edge with attributes
                G.add_edge(
                    row['From_Channel_ID'],
                    row['To_Channel_ID'],
                    connection_type=row.get('ConnectionType', 'forward'),
                    weight=float(row.get('Weight', 1))
                )

        logger.info(
            "Loaded network with %d nodes and %d edges",
            G.number_of_nodes(),
            G.number_of_edges(),
        )
        return G

    except Exception as e:
        logger.error("Error loading edge list: %s", e)
        return nx.DiGraph()  # Return empty graph on error


def calculate_network_metrics(G: nx.DiGraph) -> dict[str, Any]:
    """Calculate various network metrics for the graph.

    Args:
        G (nx.DiGraph): The network graph.

    Returns:
        dict[str, Any]: Dictionary containing calculated metrics.
    """
    metrics: dict[str, Any] = {}

    # Basic metrics
    metrics['node_count'] = G.number_of_nodes()
    metrics['edge_count'] = G.number_of_edges()
    metrics['density'] = nx.density(G)

    # Calculate connected components (for directed graph)
    # Weak components consider directions as undirected
    metrics['weakly_connected_components'] = nx.number_weakly_connected_components(G)

    # Strong components require following directions
    metrics['strongly_connected_components'] = nx.number_strongly_connected_components(G)

    # Top nodes by degree
    in_degrees = dict(G.in_degree())
    out_degrees = dict(G.out_degree())

    metrics['top_receivers'] = sorted(in_degrees.items(), key=lambda x: x[1], reverse=True)[:10]
    metrics['top_sources'] = sorted(out_degrees.items(), key=lambda x: x[1], reverse=True)[:10]

    # Get connection type counts
    connection_types = {}
    for _, _, attr in G.edges(data=True):
        conn_type = attr.get('connection_type', 'forward')
        connection_types[conn_type] = connection_types.get(conn_type, 0) + 1

    metrics['connection_types'] = connection_types

    # Average path length (only if graph is connected)
    try:
        # Convert to undirected for path length calculation
        UG = G.to_undirected()
        largest_cc = max(nx.connected_components(UG), key=len)
        largest_cc_graph = UG.subgraph(largest_cc)
        metrics['average_path_length'] = nx.average_shortest_path_length(largest_cc_graph)
    except Exception as e:
        logger.warning("Could not calculate average path length: %s", e)
        metrics['average_path_length'] = None

    return metrics


def log_network_summary(metrics: dict[str, Any], G: nx.DiGraph) -> None:
    """Log a summary of the network metrics."""
    logger.info("\n===== NETWORK ANALYSIS SUMMARY =====\n")

    logger.info("Network Size:")
    logger.info("  Nodes (Channels): %d", metrics['node_count'])
    logger.info("  Edges (Connections): %d", metrics['edge_count'])
    logger.info("  Density: %.4f", metrics['density'])

    logger.info("\nConnectivity:")
    logger.info("  Weakly Connected Components: %d", metrics['weakly_connected_components'])
    logger.info("  Strongly Connected Components: %d", metrics['strongly_connected_components'])

    if metrics['average_path_length']:
        logger.info("  Average Path Length: %.2f", metrics['average_path_length'])

    logger.info("\nConnection Types:")
    for conn_type, count in metrics['connection_types'].items():
        logger.info("  %s: %d (%.1f%%)", conn_type, count, count / metrics['edge_count'] * 100)

    logger.info("\nTop Channel Sources (outgoing connections):")
    for i, (node_id, degree) in enumerate(metrics['top_sources'], 1):
        node_name = G.nodes[node_id].get('name', 'Unknown')
        logger.info("  %d. %s (ID: %s): %d outgoing connections", i, node_name, node_id, degree)

    logger.info("\nTop Channel Receivers (incoming connections):")
    for i, (node_id, degree) in enumerate(metrics['top_receivers'], 1):
        node_name = G.nodes[node_id].get('name', 'Unknown')
        logger.info("  %d. %s (ID: %s): %d incoming connections", i, node_name, node_id, degree)


def export_metrics_to_csv(metrics: dict[str, Any], output_path: str) -> None:
    """Export the network metrics to a CSV file."""
    try:
        # Basic metrics
        basic_metrics = {
            'node_count': [metrics['node_count']],
            'edge_count': [metrics['edge_count']],
            'density': [metrics['density']],
            'weakly_connected_components': [metrics['weakly_connected_components']],
            'strongly_connected_components': [metrics['strongly_connected_components']],
            'average_path_length': [metrics['average_path_length']]
        }

        # Create DataFrames
        basic_df = pd.DataFrame(basic_metrics)

        # Connection types
        conn_types_data = [[conn_type, count] for conn_type, count in metrics['connection_types'].items()]
        conn_types_df = pd.DataFrame(conn_types_data, columns=['connection_type', 'count'])

        # Top sources
        top_sources_data = [[i + 1, node_id, degree] for i, (node_id, degree) in enumerate(metrics['top_sources'])]
        top_sources_df = pd.DataFrame(top_sources_data, columns=['rank', 'node_id', 'outgoing_connections'])

        # Top receivers
        top_receivers_data = [[i + 1, node_id, degree] for i, (node_id, degree) in enumerate(metrics['top_receivers'])]
        top_receivers_df = pd.DataFrame(top_receivers_data, columns=['rank', 'node_id', 'incoming_connections'])

        # Save to Excel with multiple sheets
        with pd.ExcelWriter(output_path) as writer:
            basic_df.to_excel(writer, sheet_name='Basic Metrics', index=False)
            conn_types_df.to_excel(writer, sheet_name='Connection Types', index=False)
            top_sources_df.to_excel(writer, sheet_name='Top Sources', index=False)
            top_receivers_df.to_excel(writer, sheet_name='Top Receivers', index=False)

        logger.info("Exported metrics to %s", output_path)

    except Exception as e:
        logger.error("Error exporting metrics to CSV: %s", e)


def generate_gephi_file(G: nx.DiGraph, output_path: str) -> None:
    """Generate a GEXF file for use with Gephi visualization software."""
    try:
        # Add readable labels to nodes
        for node, attr in G.nodes(data=True):
            username = attr.get('username', '')
            name = attr.get('name', '')
            G.nodes[node]['label'] = f"{name} (@{username})" if username else name

        # Write to GEXF file
        nx.write_gexf(G, output_path)
        logger.info("Generated Gephi file at %s", output_path)
        logger.info("You can open this file in Gephi for visualization and further analysis.")

    except Exception as e:
        logger.error("Error generating Gephi file: %s", e)


def generate_network_visualization(G: nx.DiGraph, output_path: str) -> None:
    """Generate a basic network visualization using matplotlib."""
    try:
        # Create a simplified graph for visualization (limit to 100 nodes if larger)
        if G.number_of_nodes() > 100:
            logger.info("Network is large, generating simplified visualization")
            # Get top 100 nodes by degree
            degrees = dict(G.degree())
            top_nodes = sorted(degrees.items(), key=lambda x: x[1], reverse=True)[:100]
            top_node_ids = [node_id for node_id, _ in top_nodes]
            G_viz = G.subgraph(top_node_ids)
        else:
            G_viz = G

        # Create figure
        plt.figure(figsize=(12, 10))

        # Create a spring layout
        pos = nx.spring_layout(G_viz, seed=42)

        # Get connection types for edge colors
        edge_colors = []
        for _, _, attr in G_viz.edges(data=True):
            conn_type = attr.get('connection_type', 'forward')
            if conn_type == 'forward':
                edge_colors.append('blue')
            elif conn_type == 'recommendation':
                edge_colors.append('green')
            elif conn_type == 'outbound_link':
                edge_colors.append('red')
            else:
                edge_colors.append('gray')

        # Draw the network
        nx.draw_networkx_nodes(G_viz, pos, node_size=50, alpha=0.8)
        nx.draw_networkx_edges(G_viz, pos, alpha=0.5, arrows=True,
                               edge_color=edge_colors, width=0.5)

        # Add a title
        plt.title(f'Telegram Channel Network (showing {G_viz.number_of_nodes()} nodes)')

        # Add a legend
        legend_elements = [
            plt.Line2D([0], [0], color='blue', lw=2, label='Forward'),
            plt.Line2D([0], [0], color='green', lw=2, label='Recommendation'),
            plt.Line2D([0], [0], color='red', lw=2, label='Outbound Link')
        ]
        plt.legend(handles=legend_elements)

        # Remove axis
        plt.axis('off')

        # Save the figure
        plt.savefig(output_path, dpi=300, bbox_inches='tight')
        plt.close()

        logger.info("Generated network visualization at %s", output_path)

    except Exception as e:
        logger.error("Error generating network visualization: %s", e)


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='Network Analysis for Telegram Snowball Sampling Data')
    parser.add_argument('--edge-list', '-e', dest='edge_list_path',
                        default=os.path.join(Config.EDGE_LIST_FOLDER, Config.EDGE_LIST_FILENAME),
                        help='Path to the edge list CSV file')
    parser.add_argument('--output-dir', '-o', dest='output_dir',
                        default='network_analysis',
                        help='Directory to save output files')

    args = parser.parse_args()

    # Create output directory if it doesn't exist
    os.makedirs(args.output_dir, exist_ok=True)

    # Output file paths
    metrics_output_path = os.path.join(args.output_dir, 'network_metrics.xlsx')
    gephi_output_path = os.path.join(args.output_dir, 'network.gexf')
    viz_output_path = os.path.join(args.output_dir, 'network_visualization.png')

    # Load the edge list and create a graph
    G = load_edge_list(args.edge_list_path)

    if G.number_of_nodes() == 0:
        logger.error("No nodes found in the edge list. Please check the file path and format.")
        exit(1)

    # Calculate network metrics
    metrics = calculate_network_metrics(G)

    # Log network summary
    log_network_summary(metrics, G)

    # Export metrics to CSV
    export_metrics_to_csv(metrics, metrics_output_path)

    # Generate Gephi file
    generate_gephi_file(G, gephi_output_path)

    # Generate network visualization
    generate_network_visualization(G, viz_output_path)

    logger.info("\nAnalysis complete!")
    logger.info("All output files have been saved to the '%s' directory.", args.output_dir)
